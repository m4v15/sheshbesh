{"version":3,"sources":["logic.js","App.js","serviceWorker.js","index.js"],"names":["makeBoard","board","i","push","id","currentColour","numberOfPieces","makePieces","pieces","colour","numericArray","n","numbers","totalDistance","reduce","count","spike","spikeId","length","distanceHome","randomIndex","array","Math","floor","random","randomise","stepDifference","colourSpikeIds","green","purple","numOfRemainingPieces","_loop","index","randomPieceIndex","pieceColour","oppositeColour","forbiddenSpikeIds","currentColourSpikeIds","allowedSpikeIds","filter","number","includes","randomSpikeId","find","Object","toConsumableArray","slice","concat","abs","idMap","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","App","generateRandomBoard","_randomise","randomBoard","_this","setState","state","renderSpikes","spikes","pos","react_default","a","createElement","className","renderPieces","max","text","renderStartingSetup","pieceArray","map","handleClick","this","react","class","onClick","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4e496e19.chunk.js","sourcesContent":["const makeBoard = () => {\n  /*\n  Initialise a board as an array of objects, each object representing a spike\n  spike has 3 properties: id, currentColour, number of Pieces\n  ID's are 1-24, with 1 top left and 24 bottom left\n  Green pieces must travel to the top left, anti-clockwise \n  Purple pieces must travel to the bottom left, clockwise \n  */\n  let board = []\n  for (let i = 1; i <= 24; i++) {\n    board.push({\n      \"id\": i,\n      \"currentColour\": null,\n      \"numberOfPieces\": 0\n    })\n  }\n  return board\n}\n\nconst makePieces = () => {\n  /*\n  Initialise an array of piece objects, each object representing a piece\n  spike has 1 property, colour. 15 with green and 15 with purple.\n  This acts as a \"bag\" to pick from randomly\n  */\n  let pieces = []\n  for (let i = 1; i <= 30; i++) {\n    let colour = i % 2 === 0 ? \"green\" : \"purple\"\n    pieces.push({ colour })\n  }\n  return pieces\n}\n\nconst numericArray = n => {\n  /*\n  Make an array of numbers, 1 to n\n  Utility function to help generate a list of 'allowed spikes' in the randomise function\n  Allowed spikes are those which either have the same colour as the piece you are placing, or have no assigned colour\n  */\n  let numbers = []\n  for (let i = 1; i <= n; i++) {\n    numbers.push(i)\n  }\n  return numbers\n}\n\nconst distanceHome = (colour, board) => spikeId => {\n  /*\n  How many steps a piece would have to travel to get chalked off\n  Used to naively determine 'even-ness' of the board set up\n  */\n  const distance = (colour === 'green') ? spikeId : (board.length + 1 - spikeId)\n  return distance\n}\n\n\nexport const totalDistance = (board, colour) => {\n  /*\n  Uses distanceHome to determine total steps needed for a particular colour for a given board\n  */\n  return board.reduce((count, spike) => {\n    if (spike.currentColour === colour) {\n      return count + distanceHome(colour, board)(spike.id) * spike.numberOfPieces\n    }\n    return count\n  }, 0)\n}\n\nconst inverseColour = colour => (colour === 'green') ? 'purple' : 'green'\n\nconst randomIndex = array => Math.floor(Math.random() * array.length)\n\nconst removeElement = (array, index) => [...array.slice(0, index), ...array.slice(index + 1)]\n\nconst randomise = () => {\n  /*\n  Initialise a board and then randomly assign 30 pieces (15 green, 15 purple) to the spikes. Using total distance, only return when both colours have roughly the same total number of steps home (within 3)\n\n  1. Initialise board, keep track of cycle number\n  2. Initialise an array of pieces - our \"bag\" we pick from\n  3. We want to keep track of the spikeId's that each colour \"owns\", so we can filter out the id's of the forbidden spikes later on - initially all spikes are available\n  4. While we still have pieces in our bag, we should place them:\n    a. Pick a random piece from our array, and get it's colour\n    b. get the opposite colour as well\n    c. get the a list of allowed spikes by filtering out any spikes already claimed by the other colour\n      * if the current colout already has 6 spikes, it can only choose from those spikes\n    d. get a random spike on our board from that list of allowed spikeIds\n    e. Change colour and number of pieces properties on the spike as appropriate\n    f. add the spike id to those belonging to this colour\n    g. remove this piece from our piece \"bag\" array - this will mean if we get a load of the same colour in a row, it should normalise to then choosing the other colour\n    h. loop until piece \"bag\" is empty\n  5. Check the steps each colour needs to end - if it is too small start all over again.\n  6. return and object containing the board, and the number of cycles it took to get there.\n\n  */\n  let board\n  let stepDifference = 5\n  let count = 0\n  while (stepDifference > 3) {\n    count++\n    board = makeBoard()\n    let pieces = makePieces()\n    let colourSpikeIds = { green: [], purple: [] }\n    let numOfRemainingPieces = pieces.length\n    while (numOfRemainingPieces) {\n      let randomPieceIndex = randomIndex(pieces)\n      let randomPiece = pieces[randomPieceIndex]\n      let pieceColour = randomPiece.colour\n      let oppositeColour = inverseColour(pieceColour)\n      let forbiddenSpikeIds = colourSpikeIds[oppositeColour]\n\n      let currentColourSpikeIds = colourSpikeIds[pieceColour]\n\n      let allowedSpikeIds = currentColourSpikeIds.length < 6\n        ? numericArray(24).filter(number => {\n          return !forbiddenSpikeIds.includes(number)\n        })\n        : currentColourSpikeIds\n\n      let randomSpikeId = allowedSpikeIds[randomIndex(allowedSpikeIds)]\n\n      const spike = board.find(spike => spike.id === randomSpikeId)\n      spike.currentColour = pieceColour\n      spike.numberOfPieces++\n\n      colourSpikeIds[pieceColour].push(randomSpikeId)\n\n      pieces = removeElement(pieces, randomPieceIndex)\n\n      numOfRemainingPieces = pieces.length\n    }\n    stepDifference = Math.abs(totalDistance(board, 'green') - totalDistance(board, 'purple'))\n  }\n  return { board, count }\n}\n\n// const { board: randomBoard, count } = randomise()\n\n\n\n\n\n\n// BELOW IS CODE TO TRY THIS OUT\n// \n// Uncomment the console logs to make some boards\n// -------------------------------------\n// console.log(randomBoard)\n// console.log('Green steps needed: ', totalDistance(randomBoard, 'green'))\n// console.log('Purple steps needed: ', totalDistance(randomBoard, 'purple'))\n// console.log('Step Difference: ', totalDistance(randomBoard, 'green') - totalDistance(randomBoard, 'purple'))\n// console.log('Cycles needed: ', count)\n\n\n// BELOW IS A FUNCTION TO TEST WE ARE ADDING CORRECT NUMBER OF PIECES \n// \n// Did not have wifi so just had to check\n// -------------------------------------\n// const totalPieces = (board, colour) => {\n//     return board.reduce((count, spike) => {\n//       if (colour && spike.currentColour !== colour) {\n//         return count\n//       }\n//       return count + spike.numberOfPieces\n//     }, 0)\n//   }\n\n\n// BELOW IS TESTS FOR THE DISTANCE HOME\n// \n// Did not have wifi so just had to check\n// -------------------------------------\n// const testCase = [{ id: 1, currentColour: 'green', numberOfPieces: 1 },\n// { id: 2, currentColour: 'purple', numberOfPieces: 1 },\n// { id: 3, currentColour: 'green', numberOfPieces: 2 },\n// { id: 4, currentColour: 'green', numberOfPieces: 1 }]\n\n// console.log('Green steps needed: ', totalDistance(testCase, 'green'))\n// console.log('Purple steps needed: ', totalDistance(testCase, 'purple'))\n// console.log('Green correct: ', (totalDistance(testCase, 'green') === 11))\n// console.log('Purple correct: ', (totalDistance(testCase, 'purple') === 3))\n\n\nexport default randomise","import React, { Component, Fragment } from 'react';\nimport './App.css';\nimport './grid.css';\n\nimport randomise, { totalDistance } from './logic.js'\n\nconst idMap = {\n  1: 'col-1',\n  2: 'col-2',\n  3: 'col-3',\n  4: 'col-4',\n  5: 'col-5',\n  6: 'col-6',\n  7: 'col-8',\n  8: 'col-9',\n  9: 'col-10',\n  10: 'col-11',\n  11: 'col-12',\n  12: 'col-13',\n  13: 'col-13',\n  14: 'col-12',\n  15: 'col-11',\n  16: 'col-10',\n  17: 'col-9',\n  18: 'col-8',\n  19: 'col-6',\n  20: 'col-5',\n  21: 'col-4',\n  22: 'col-3',\n  23: 'col-2',\n  24: 'col-1',\n}\n\nclass App extends Component {\n\n  // generatePieces = () => {\n  //   let pieces = []\n  //   for (let i = 1; i < 7; i++) {\n  //     let colour = i % 2 === 0 ? \"green\" : \"purple\"\n  //     pieces.push({ colour, col: `col-${i}`, row: `row-${i}` })\n  //   }\n  //   this.setState({ pieces })\n  // }\n\n  generateRandomBoard = () => {\n    const { board: randomBoard, count } = randomise()\n\n    this.setState({\n      board: randomBoard,\n      count\n    })\n  }\n\n  state = {\n    board: [],\n    count: 0\n  }\n\n  renderSpikes = () => {\n    let spikes = []\n    for (let i = 1; i <= 24; i++) {\n      let colour = i % 2 === 0 ? 'black' : 'red'\n      let pos = i > 12 ? 'spike-bottom' : 'spike-top'\n      spikes.push(<div className={`${pos} ${colour}`}></div>)\n    }\n    return spikes\n  }\n\n  renderPieces = (spike) => {\n    const { numberOfPieces, currentColour: colour } = spike\n    if (numberOfPieces === 0) {\n      return\n    }\n    let pieces = []\n    let max = (numberOfPieces >= 6) ? 6 : numberOfPieces\n    for (let i = 0; i < max; i++) {\n      let text = (i === 0 && numberOfPieces > 6) ? numberOfPieces : ''\n      pieces.push(<div className={`piece ${colour}`}>{text}</div>)\n    }\n    return pieces\n\n\n  }\n\n  renderStartingSetup = pieceArray => this.state.board.map(spike => {\n    let pos = spike.id > 12 ? 'board-bottom' : 'board-top'\n    return (<div className={`${pos} ${idMap[spike.id]} spike-area`}>\n      {this.renderPieces(spike)}\n    </div>)\n  })\n\n  handleClick = () => {\n    this.generateRandomBoard()\n  }\n\n  componentWillMount() {\n    this.generateRandomBoard()\n  }\n\n  render() {\n    return (\n      <Fragment>\n        <div className={`page-container`}>\n          <div className='home'>Green Home</div>\n          <div className={`board-container`}>\n            <div className=\"board back\">\n              {this.renderSpikes()}\n              <div className=\"bar\"></div>\n            </div>\n            <div className=\"board front\">\n              {this.renderStartingSetup()}\n            </div>\n          </div>\n          <div className='home'>Purple Home</div>\n          <div className='stats'>\n            <div>Green pip count:{totalDistance(this.state.board, 'green')}</div>\n            <div>Purple pip count:{totalDistance(this.state.board, 'purple')}</div>\n          </div>\n          <div class=\"button-container\" onClick={this.handleClick}>\n            <p class=\"button\">Again!</p>\n          </div>\n        </div>\n      </Fragment>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}